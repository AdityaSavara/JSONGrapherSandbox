<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math.js Unit Solver</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.1/math.min.js"></script>
</head>
<body>
    <h2>Math.js Unit Solver</h2>
    <p id="output">Computing result... open inspect and console to check log.</p>

    <script>
        // ############## PART 1: GETTING EQUATION EVALUATION TO WORK #####################
        
        function parseVariable(variableString) {
            // Split numeric part and unit
            const match = variableString.match(/([\d.]+)\s*(.*)/);
            if (!match) throw new Error("Invalid variable format.");

            const numericValue = parseFloat(match[1]);
            const unit = match[2].trim();

            return math.multiply(numericValue, math.unit(unit)); // Combine number and unit properly
        }

        // Independent variables with correct parsing
        const independentVariables = {
            x: parseVariable("2 m/s" ),
            y: parseVariable("3 meter")
        };

        // Equation
        const equationString = "x * t + y = 10 m";
        const [lhs, rhs] = equationString.split("=").map(side => side.trim());
        const dependentVariable = "t"; // Solving for t

        // Convert RHS into a unit-aware Math.js object
        const rhsValue = parseVariable(rhs);

        // Solve for t: Rearranging equation → t = (rhs - y) / x
        const tSolution = math.divide(math.subtract(rhsValue, independentVariables.y), independentVariables.x);

        // Display result
        document.getElementById("output").textContent = `Computed t: ${tSolution.toString()}`;

        function detectAndFormatUnits(equationStr) {
            // Regular expression to detect standalone numbers followed by units
            const pattern = /(\d+(\.\d+)?)\s*([a-zA-Z]+)/g;

            // Explanation of regular expression parts:
            // (\d+(\.\d+)?)
            //     \d+ → Matches one or more digits (e.g., "10", "100", "3").
            //     (\.\d+)? → Matches optional decimal values (e.g., "10.5", "3.14").
            //     This entire part captures numerical values, whether integers or decimals.
            // \s*
            //     Matches zero or more spaces between the number and the unit.
            //     Ensures flexibility in formatting (e.g., "10m" vs. "10 m").
            // ([a-zA-Z]+)
            //     Matches one or more alphabetical characters, capturing the unit symbol.
            //     Ensures that only valid unit names (e.g., "m", "s", "kg") are recognized.
            // Example Matches:
            //     "10 m"   → ("10", "", "m")
            //     "3.5 kg" → ("3.5", ".5", "kg")
            //     "100s"   → ("100", "", "s")

            // Create a temporary variable to store the transformed equation
            let formattedEquation = equationStr.replace(pattern, (match, magnitude, _, unit) => {
                let result = match; // Default to original match in case of errors
                console.log("Right before the match is used", match, magnitude, unit, "Type:", typeof match);
                try {
                    // Format as "magnitude unit" instead of using math.unit()
                    // const quantity = math.unit(`${magnitude} ${unit}`); // Commented out
                    console.log("Right after the match is used", `${magnitude} ${unit}`, "Type:", typeof magnitude);
                    result = `(${magnitude} ${unit})`;
                } catch {
                    // No assignment needed, `result` already defaults to `match`
                }
                return result;
            });

            // Return the final transformed equation
            console.log("Right before returning the formattedEquation.", formattedEquation);
            return formattedEquation;
        }


        function parseEquation(equationStr, variables) {
            // Sort variable names by length in descending order to avoid partial replacements
            const variablesSortedByName = Object.entries(variables).sort((a, b) => b[0].length - a[0].length);

            // Replace constants first
            variablesSortedByName.forEach(([varName, varValue]) => {
                if (typeof varValue !== 'object' || !varValue.units) {
                    equationStr = equationStr.replace(new RegExp(`\\b${varName}\\b`, 'g'), String(varValue));
                }
            });

            // Replace variables with magnitudes and units, formatting as "value unit"
            variablesSortedByName.forEach(([varName, varValue]) => {
                if (typeof varValue === 'object' && varValue.units) {
                    try {
                        // Format variable as "value unit" instead of using math.unit()
                        // const unitValue = math.unit(`${varValue.value} ${varValue.units}`); // Commented out
                        equationStr = equationStr.replace(new RegExp(`\\b${varName}\\b`, 'g'), `(${varValue.value} ${varValue.units})`);
                    } catch {
                        console.warn(`Invalid unit conversion for variable: ${varName}`);
                    }
                }
            });

            // Detect and format standalone numbers with units
            console.log("right before detectAndFormatUnits", equationStr);
            equationStr = detectAndFormatUnits(equationStr);

            return equationStr;
        }

        // Example usage
        const variables = {
            "x": { value: 2, units: "m / s" },
            "y": { value: 3, units: "meter" }
        };

        const equation = "(10 m - y) / x"; // Rearranged equation for solving "t"
        const equation_output = parseEquation(equation, variables);
        const evaluated_equation = math.evaluate(equation_output);

        console.log(evaluated_equation); // Outputs the calculated value of t
        console.log("output to string...", String(evaluated_equation)); // Outputs the calculated value of t

        // ############## PART 2: PARSING FULL EQUATION DICT #####################
        function parseEquationDict(equationDict) {
            function extractValueUnits(entry) {
                const trimmedEntry = entry.trim(); // Remove leading/trailing whitespace
                const splitEntry = trimmedEntry.split(" ", 2); // Split on the first space
                if (splitEntry.length > 1) {
                    const value = splitEntry[0];
                    const units = splitEntry[1]; // Everything after the number
                    return [value, units];
                } else {
                    return [parseFloat(splitEntry[0]), null]; // Handle constants without units
                }
            }

            function extractConstants(constantsDict) {
                const extractedConstants = {};
                for (const [name, value] of Object.entries(constantsDict)) {
                    extractedConstants[name] = extractValueUnits(value);
                }
                return extractedConstants;
            }

            function extractEquation(equationString) {
                const variablesList = equationString.match(/[A-Za-z]+/g) || [];
                return { equationString, variablesList };
            }

            const graphicalDimensionality = equationDict.hasOwnProperty("graphical_dimensionality")
                ? equationDict["graphical_dimensionality"]
                : 2;

            const constantsExtractedDict = extractConstants(equationDict["constants"]);
            const equationExtractedDict = extractEquation(equationDict["equation_string"]);

            const xMatch = extractValueUnits(equationDict["x_variable"]);
            const yMatch = extractValueUnits(equationDict["y_variable"]);
            let zMatch = null;
            if (graphicalDimensionality === 3) {
                zMatch = extractValueUnits(equationDict["z_variable"]);
            }

            const xVariableExtractedDict = { label: xMatch[0], units: xMatch[1] };
            const yVariableExtractedDict = { label: yMatch[0], units: yMatch[1] };
            let zVariableExtractedDict = null;
            if (graphicalDimensionality === 3) {
                zVariableExtractedDict = { label: zMatch[0], units: zMatch[1] };
            }

            function prepareIndependentVariables(constantsExtractedDict) {
                const independentVariablesDict = {};
                for (const [name, [value, units]] of Object.entries(constantsExtractedDict)) {
                    independentVariablesDict[name] = units ? `${value} ${units}` : `${value}`;
                }
                return independentVariablesDict;
            }

            const independentVariablesDict = prepareIndependentVariables(constantsExtractedDict);

            if (graphicalDimensionality === 2) {
                return [independentVariablesDict, constantsExtractedDict, equationExtractedDict, xVariableExtractedDict, yVariableExtractedDict];
            } else if (graphicalDimensionality === 3) {
                return [independentVariablesDict, constantsExtractedDict, equationExtractedDict, xVariableExtractedDict, yVariableExtractedDict, zVariableExtractedDict];
            }
        }

        const equationDict = {
                equation_string: "k = A*(e**((-Ea)/(R*T)))",
                x_variable: "T (K)",  
                y_variable: "k (s**(-1))",
                constants: {
                    Ea: "30000 (J)*(mol^(-1))",
                    R: "8.314 (J)*(mol^(-1))*(K^(-1))",
                    A: "1E13 (s**-1)",
                    e: "2.71828"
                },
                num_of_points: 10,
                x_range_default: [200, 500],
                x_range_limits: [],
                points_spacing: "Linear"
            };

        try {
            const resultExtracted = parseEquationDict(equationDict);
            console.log("Now extracting equation:");
            console.log(resultExtracted);
        } catch (error) {
            console.log(`Error: ${error.message}`);
        }



        </script>
</body>
</html>
